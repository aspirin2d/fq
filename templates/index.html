<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Font OCR Mapping Editor</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      vertical-align: middle;
    }
    th {
      background-color: #f2f2f2;
      text-align: left;
      cursor: pointer;
      user-select: none;
    }
    th.sortable:hover {
      background-color: #e2e2e2;
    }
    img.glyph {
      display: block;
      max-height: 48px;
      max-width: 48px;
    }
    input.text-input {
      width: 100%;
      box-sizing: border-box;
      padding: 4px;
      font-size: 14px;
    }
    button {
      padding: 8px 16px;
      margin: 10px 0;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Font OCR Mapping Editor</h1>
  <p>
    Below you’ll see each glyph’s image and the OCR‐extracted text. You can edit the text inline, then click 
    <strong>Save All Changes</strong> to overwrite <code>mapping.json</code> on the server. You can also sort by Charcode or Recognized Text by clicking the respective column headers.
  </p>

  <button id="save-btn">Save All Changes</button>
  <div id="status" style="margin-left: 10px; display: inline-block;"></div>

  <table id="mapping-table">
    <thead>
      <tr>
        <th class="sortable" data-key="charcode" data-order="asc">Charcode&nbsp;<span class="arrow">▲</span></th>
        <th>Glyph Image</th>
        <th class="sortable" data-key="text" data-order="none">Recognized Text&nbsp;<span class="arrow"></span></th>
      </tr>
    </thead>
    <tbody>
      <!-- Rows will be injected by JavaScript -->
    </tbody>
  </table>

  <script>
    (async function() {
      const tableBody = document.querySelector("#mapping-table tbody");
      const statusDiv = document.getElementById("status");
      let mappingData = {};
      let charcodes = [];

      try {
        const resp = await fetch("/api/data");
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        mappingData = await resp.json();
      } catch (err) {
        console.error("Error fetching mapping.json:", err);
        statusDiv.textContent = "❌ Failed to load mapping.json";
        return;
      }

      // Convert keys to integers and sort initially by charcode ascending
      charcodes = Object.keys(mappingData).map(k => parseInt(k, 10));
      charcodes.sort((a, b) => a - b);

      // Function to render the table body based on the current charcodes array
      function renderTable() {
        tableBody.innerHTML = "";
        charcodes.forEach(charcode => {
          const text = mappingData[charcode] ?? "";
          const tr = document.createElement("tr");

          const tdCode = document.createElement("td");
          tdCode.textContent = charcode;
          tr.appendChild(tdCode);

          const tdImg = document.createElement("td");
          const img = document.createElement("img");
          img.src = `/glyphs/${charcode}.png`;
          img.alt = `U+${charcode.toString(16).toUpperCase().padStart(4, "0")}`;
          img.className = "glyph";
          tdImg.appendChild(img);
          tr.appendChild(tdImg);

          const tdText = document.createElement("td");
          const input = document.createElement("input");
          input.type = "text";
          input.value = text;
          input.className = "text-input";
          input.dataset.charcode = charcode;
          tdText.appendChild(input);
          tr.appendChild(tdText);

          tableBody.appendChild(tr);
        });
      }

      // Initial render
      renderTable();

      // Sorting logic
      document.querySelectorAll('th.sortable').forEach(header => {
        header.addEventListener('click', () => {
          const key = header.dataset.key;         // 'charcode' or 'text'
          let order = header.dataset.order;       // 'asc', 'desc', or 'none'

          // Reset all headers except the clicked one
          document.querySelectorAll('th.sortable').forEach(h => {
            if (h !== header) {
              h.dataset.order = 'none';
              h.querySelector('.arrow').textContent = '';
            }
          });

          // Cycle order: none -> asc -> desc -> asc...
          if (order === 'none') {
            order = 'asc';
          } else if (order === 'asc') {
            order = 'desc';
          } else {
            order = 'asc';
          }
          header.dataset.order = order;

          // Update arrow indicator
          const arrowSpan = header.querySelector('.arrow');
          arrowSpan.textContent = order === 'asc' ? '▲' : (order === 'desc' ? '▼' : '');

          if (key === 'charcode') {
            charcodes.sort((a, b) => {
              return order === 'asc' ? a - b : b - a;
            });
          } else if (key === 'text') {
            charcodes.sort((a, b) => {
              const ta = mappingData[a] ?? '';
              const tb = mappingData[b] ?? '';
              if (ta < tb) return order === 'asc' ? -1 : 1;
              if (ta > tb) return order === 'asc' ? 1 : -1;
              return 0;
            });
          }

          renderTable();
        });
      });

      // Save button handler
      document.getElementById("save-btn").addEventListener("click", async () => {
        statusDiv.textContent = "Saving…";
        // Gather all inputs, build a new mapping object
        document.querySelectorAll("input.text-input").forEach(inputElem => {
          const code = inputElem.dataset.charcode;
          const val = inputElem.value;
          mappingData[code] = val;
        });

        try {
          const response = await fetch("/api/save", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(mappingData),
          });
          const result = await response.json();
          if (response.ok && result.success) {
            statusDiv.textContent = "✅ Saved successfully!";
          } else {
            throw new Error(result.error || "Unknown error");
          }
        } catch (err) {
          console.error("Error saving mapping:", err);
          statusDiv.textContent = "❌ Save failed: " + err.message;
        }

        setTimeout(() => { statusDiv.textContent = ""; }, 3000);
      });
    })();
  </script>
</body>
</html>
